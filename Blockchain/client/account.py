# Elliptic Curve Cryptography (ECC) is a public-key cryptography system that relies on the mathematical properties of elliptic curves over finite fields. ECC provides a secure alternative to traditional public
import sys
sys.path.append('/home/danio/personal/wa/python_blockchain')
from Blockchain.server.core.EllepticCurve.EllepticCurve import Sha256Point
from Blockchain.server.tools.tools import hash160, hash256
import secrets
"""
The code generates a private key, calculates the corresponding public key, and then converts the public key into a Bitcoin-compatible public address.

1. Inside the createKeys() method, the base point G of the elliptic curve is defined using the provided Gx and Gy coordinates.
2. A private key is generated using the secrets.randbits() function, which generates a random integer of 256 bits.
3. The public key is calculated by multiplying the private key with the base point G.
4. The public key is compressed by checking the parity of the y_point coordinate. If it's even, a prefix of 0x02 is added; otherwise, a prefix of 0x03 is added. The x_point coordinate is then appended to the prefix.
5. The compressed public key is hashed using the hash160() function to generate a 160-bit hash.
6. A prefix of 0x00 is added to the hash to indicate the mainnet network.
7. The checksum is calculated by hashing the first 4 bytes of the concatenated prefix and hash using the hash256() function. The checksum is then appended to the concatenated prefix and hash.
8. The public address is generated by converting the concatenated prefix and hash to a base 58 string. Leading zeros are accounted for by adding a corresponding number of 1 characters at the beginning of the base 58 string.
9. The final public address is returned as the output of the createKeys() method.
"""
class Account:
    def createKeys(self):
        Gx = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798
        Gy = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8

        G = Sha256Point(Gx, Gy)

        # this is our private key of 256 bits
        self.private_key = secrets.randbits(256)
        uncompressed_public_key = self.private_key * G
        x_point = uncompressed_public_key.x
        y_point = uncompressed_public_key.y

        # if y_point is even, we write 0x02, otherwise we write 0x03
        # big = we write number from right to left, small = we write number from left to right
        # .num is used to get the integer value
        compressed_key = (b"\x02" if y_point.num % 2 == 0 else b"\x03") + x_point.num.to_bytes(32, "big")
    
        hsh160 = hash160(compressed_key)
        # prefix for mainnet
        main_prefix = b'\x00'
        new_address = main_prefix + hsh160
        # checksum
        checksum = hash256(new_address)[:4]
        new_address += checksum

        BASE58_ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"

        # check the leading 0
        count = 0
        for c in new_address:
            if c == 0:
                count += 1
            else:
                break
        
        num = int.from_bytes(new_address, 'big')
        prefix = '1' * count

        result = ''

        while num > 0:
            num, mod = divmod(num, 58)
            result = BASE58_ALPHABET[mod] + result
        
        # public address is the final output after the base 58 conversion
        self.public_address = prefix + result
        print(f'Public Address: {self.public_address}')
        print(f'Private Key: {self.private_key}')
        print(f"Xpoint {x_point} \n Ypoint {y_point}")

if __name__ == '__main__':
    account = Account()
    account.createKeys()
    